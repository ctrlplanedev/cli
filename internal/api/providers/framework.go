package providers

import (
	"context"
	"fmt"
	"strings"

	"github.com/ctrlplanedev/cli/internal/api"
	"github.com/ctrlplanedev/cli/internal/api/resolver"
	"github.com/google/uuid"
)

// Context provides the execution context for CRUD operations.
type Context interface {
	Ctx() context.Context
	WorkspaceIDValue() string
	APIClient() *api.ClientWithResponses
	ResolverProvider() *resolver.APIResolver
}

// CRUDProvider defines the interface for resource CRUD operations.
// This is similar to Pulumi's resource provider model where each resource type
// implements Create, Read, Update, Delete operations.
//
// Example usage:
//
//	type MyResourceProvider struct{}
//
//	func (p *MyResourceProvider) TypeName() string { return "MyResource" }
//	func (p *MyResourceProvider) Order() int { return 500 }
//	func (p *MyResourceProvider) Parse(raw []byte) (ResourceSpec, error) { ... }
type CRUDProvider interface {
	// TypeName returns the document type identifier (e.g., "Deployment", "Environment")
	TypeName() string

	// Order returns the processing priority. Higher numbers are processed first.
	// This is important for dependency ordering (e.g., Systems before Deployments)
	Order() int

	// Parse parses raw YAML bytes into a ResourceSpec
	Parse(raw []byte) (ResourceSpec, error)
}

// ResourceSpec represents a parsed resource document with CRUD capabilities.
// Each document type should implement this interface to define its behavior.
type ResourceSpec interface {
	// Name returns the display name of the resource
	Name() string

	// Identity returns a unique identifier for this resource within its type.
	// This is used to find existing resources during updates.
	// Examples: slug for deployments, name for environments, identifier for resources
	Identity() string

	// Lookup searches for an existing resource matching this spec.
	// Returns the existing resource ID if found, empty string if not found.
	// Returns an error only if the lookup operation itself fails.
	Lookup(ctx Context) (existingID string, err error)

	// Create creates a new resource with the given ID.
	// The ID is pre-generated by the framework.
	Create(ctx Context, id string) error

	// Update updates an existing resource with the given ID.
	Update(ctx Context, existingID string) error

	// Delete removes the resource with the given ID.
	// Returns nil if the resource doesn't exist (idempotent delete).
	Delete(ctx Context, existingID string) error
}

// Selector represents a key=value selector for resource pruning.
type Selector struct {
	Key   string
	Value string
}

// ExistingResource represents a resource discovered from the API.
type ExistingResource struct {
	Identifier string
	Metadata   map[string]string
}

// ExistingResourceLister allows querying existing resources with a filter.
// Implementations can use the filter to limit server-side results when supported.
type ExistingResourceLister interface {
	ListExisting(ctx Context, selector *Selector) ([]ExistingResource, error)
}

// ParseSelector parses a selector string in key=value format.
// Returns nil if the input is empty.
func ParseSelector(raw string) (*Selector, error) {
	raw = strings.TrimSpace(raw)
	if raw == "" {
		return nil, nil
	}

	parts := strings.SplitN(raw, "=", 2)
	if len(parts) != 2 {
		return nil, fmt.Errorf("selector must be in key=value format")
	}

	key := strings.TrimSpace(parts[0])
	value := strings.TrimSpace(parts[1])
	if key == "" || value == "" {
		return nil, fmt.Errorf("selector must include non-empty key and value")
	}

	return &Selector{Key: key, Value: value}, nil
}

// MatchesMetadata returns true if the metadata contains the selector key/value.
func (s Selector) MatchesMetadata(metadata map[string]string) bool {
	if metadata == nil {
		return false
	}
	return metadata[s.Key] == s.Value
}

// ApplyMetadata ensures the selector key/value is present in metadata.
func (s Selector) ApplyMetadata(metadata map[string]string) map[string]string {
	if metadata == nil {
		metadata = make(map[string]string)
	}
	metadata[s.Key] = s.Value
	return metadata
}

// CelExpression returns a CEL expression for filtering metadata by selector.
func (s Selector) CelExpression() string {
	key := strings.ReplaceAll(s.Key, "\\", "\\\\")
	key = strings.ReplaceAll(key, "\"", "\\\"")

	value := strings.ReplaceAll(s.Value, "\\", "\\\\")
	value = strings.ReplaceAll(value, "\"", "\\\"")

	return fmt.Sprintf("metadata[\"%s\"] == \"%s\"", key, value)
}

// Result represents the result of applying a resource spec.
type Result struct {
	Type   string
	Name   string
	Action string // "created", "updated", "unchanged", "upserted"
	ID     string
	Error  error
}

// DeleteResult represents the result of deleting a resource spec.
type DeleteResult struct {
	Type   string
	Name   string
	Action string // "deleted", "not_found"
	ID     string
	Error  error
}

// ProviderEngine orchestrates CRUD operations using the provider pattern.
// It handles the common logic of: lookup → create or update.
type ProviderEngine struct {
	providers map[string]CRUDProvider
}

// NewProviderEngine creates a new provider engine instance.
func NewProviderEngine() *ProviderEngine {
	return &ProviderEngine{
		providers: make(map[string]CRUDProvider),
	}
}

// Register registers a CRUD provider for a document type.
func (e *ProviderEngine) Register(provider CRUDProvider) {
	e.providers[provider.TypeName()] = provider
}

// GetProvider returns the provider for a document type.
func (e *ProviderEngine) GetProvider(docType string) (CRUDProvider, bool) {
	p, ok := e.providers[docType]
	return p, ok
}

// ListProviders returns all registered providers.
func (e *ProviderEngine) ListProviders() []CRUDProvider {
	providers := make([]CRUDProvider, 0, len(e.providers))
	for _, p := range e.providers {
		providers = append(providers, p)
	}
	return providers
}

// Parse parses a raw YAML document into a ResourceSpec using the appropriate provider.
func (e *ProviderEngine) Parse(docType string, raw []byte) (ResourceSpec, error) {
	provider, ok := e.providers[docType]
	if !ok {
		return nil, fmt.Errorf("unknown document type: %s", docType)
	}
	return provider.Parse(raw)
}

// Apply applies a resource spec, creating or updating as needed.
// This implements the core Pulumi-like reconciliation logic:
// 1. Lookup existing resource
// 2. If exists → Update
// 3. If not exists → Create with new ID
func (e *ProviderEngine) Apply(ctx Context, docType string, spec ResourceSpec) Result {
	result := Result{
		Type: docType,
		Name: spec.Name(),
	}

	// Step 1: Lookup existing resource
	existingID, err := spec.Lookup(ctx)
	if err != nil {
		result.Error = fmt.Errorf("lookup failed: %w", err)
		return result
	}

	// Step 2: Create or Update
	if existingID != "" {
		// Resource exists - update it
		if err := spec.Update(ctx, existingID); err != nil {
			result.Error = fmt.Errorf("update failed: %w", err)
			return result
		}
		result.ID = existingID
		result.Action = "updated"
	} else {
		// Resource doesn't exist - create it
		newID := uuid.New().String()
		if err := spec.Create(ctx, newID); err != nil {
			result.Error = fmt.Errorf("create failed: %w", err)
			return result
		}
		result.ID = newID
		result.Action = "created"
	}

	return result
}

// Delete deletes a resource spec.
// This implements idempotent deletion:
// 1. Lookup existing resource
// 2. If exists → Delete
// 3. If not exists → Return not_found (not an error)
func (e *ProviderEngine) Delete(ctx Context, docType string, spec ResourceSpec) DeleteResult {
	result := DeleteResult{
		Type: docType,
		Name: spec.Name(),
	}

	// Step 1: Lookup existing resource
	existingID, err := spec.Lookup(ctx)
	if err != nil {
		result.Error = fmt.Errorf("lookup failed: %w", err)
		return result
	}

	// Step 2: Delete if exists
	if existingID == "" {
		result.Action = "not_found"
		return result
	}

	if err := spec.Delete(ctx, existingID); err != nil {
		result.Error = fmt.Errorf("delete failed: %w", err)
		return result
	}

	result.ID = existingID
	result.Action = "deleted"
	return result
}

// PreviewResult represents the result of a preview operation.
type PreviewResult struct {
	Type       string
	Name       string
	Action     string // "create", "update", "unchanged", "delete"
	ExistingID string
	Changes    []string // Description of what would change
}

// Preview previews what would happen if the resource spec was applied.
// This is useful for dry-run/plan operations.
func (e *ProviderEngine) Preview(ctx Context, docType string, spec ResourceSpec) PreviewResult {
	result := PreviewResult{
		Type: docType,
		Name: spec.Name(),
	}

	existingID, err := spec.Lookup(ctx)
	if err != nil {
		result.Action = "error"
		result.Changes = []string{fmt.Sprintf("lookup failed: %v", err)}
		return result
	}

	if existingID != "" {
		result.Action = "update"
		result.ExistingID = existingID
	} else {
		result.Action = "create"
	}

	return result
}

// BatchApplyOptions configures batch apply behavior.
type BatchApplyOptions struct {
	// ContinueOnError continues processing even if one resource fails
	ContinueOnError bool
	// DryRun performs a preview instead of actual apply
	DryRun bool
}

// BatchApply applies multiple resource specs in order.
func (e *ProviderEngine) BatchApply(ctx Context, specs []TypedSpec, opts BatchApplyOptions) []Result {
	results := make([]Result, 0, len(specs))

	for _, ts := range specs {
		if opts.DryRun {
			preview := e.Preview(ctx, ts.Type, ts.Spec)
			results = append(results, Result{
				Type:   preview.Type,
				Name:   preview.Name,
				Action: preview.Action + " (dry-run)",
				ID:     preview.ExistingID,
			})
			continue
		}

		result := e.Apply(ctx, ts.Type, ts.Spec)
		results = append(results, result)

		if result.Error != nil && !opts.ContinueOnError {
			break
		}
	}

	return results
}

// TypedSpec wraps a ResourceSpec with its type information.
type TypedSpec struct {
	Type string
	Spec ResourceSpec
}

// DefaultProviderEngine is the global provider engine instance.
// Providers should register themselves in init() functions.
var DefaultProviderEngine = NewProviderEngine()

// RegisterProvider registers a provider with the default engine.
func RegisterProvider(provider CRUDProvider) {
	DefaultProviderEngine.Register(provider)
}

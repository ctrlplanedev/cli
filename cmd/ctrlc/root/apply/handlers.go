package apply

import (
	"context"
	"fmt"

	"github.com/ctrlplanedev/cli/internal/api"
	"github.com/google/uuid"
	"github.com/gosimple/slug"
)

// getSlug returns the provided slug if set, otherwise generates one from the name
func getSlug(providedSlug *string, name string) string {
	if providedSlug != nil && *providedSlug != "" {
		return *providedSlug
	}
	return slug.Make(name)
}

// ResourceResolver helps resolve resource names to IDs
type ResourceResolver struct {
	client      *api.ClientWithResponses
	workspaceID string
	// Cache for resolved systems by name
	systemCache map[string]string
}

// NewResourceResolver creates a new resolver
func NewResourceResolver(client *api.ClientWithResponses, workspaceID string) *ResourceResolver {
	return &ResourceResolver{
		client:      client,
		workspaceID: workspaceID,
		systemCache: make(map[string]string),
	}
}

// ResolveSystemID resolves a system name or ID to an actual ID
func (r *ResourceResolver) ResolveSystemID(ctx context.Context, nameOrID string) (string, error) {
	// Check if it's already a valid UUID
	if _, err := uuid.Parse(nameOrID); err == nil {
		return nameOrID, nil
	}

	// Check cache
	if id, ok := r.systemCache[nameOrID]; ok {
		return id, nil
	}

	// Look up by name
	resp, err := r.client.ListSystemsWithResponse(ctx, r.workspaceID, nil)
	if err != nil {
		return "", fmt.Errorf("failed to list systems: %w", err)
	}

	if resp.JSON200 == nil {
		return "", fmt.Errorf("failed to list systems: %s", string(resp.Body))
	}

	for _, sys := range resp.JSON200.Items {
		r.systemCache[sys.Name] = sys.Id
		if sys.Name == nameOrID || sys.Slug == nameOrID {
			return sys.Id, nil
		}
	}

	return "", fmt.Errorf("system not found: %s", nameOrID)
}

// buildSelector converts a SelectorConfig to an API Selector
func buildSelector(cfg *SelectorConfig) (*api.Selector, error) {
	if cfg == nil {
		return nil, nil
	}

	var selector api.Selector

	if cfg.Cel != nil {
		if err := selector.FromCelSelector(api.CelSelector{Cel: *cfg.Cel}); err != nil {
			return nil, fmt.Errorf("failed to create CEL selector: %w", err)
		}
		return &selector, nil
	}

	if cfg.Json != nil {
		if err := selector.FromJsonSelector(api.JsonSelector{Json: cfg.Json}); err != nil {
			return nil, fmt.Errorf("failed to create JSON selector: %w", err)
		}
		return &selector, nil
	}

	return nil, nil
}

// ApplySystem creates or updates a system
// Uses slug as the stable identifier for matching. If no slug is provided, one is generated from the name.
func ApplySystem(ctx context.Context, client *api.ClientWithResponses, workspaceID string, doc *SystemDocument) (*ApplyResult, error) {
	result := &ApplyResult{
		Kind: KindSystem,
		Name: doc.Name,
	}

	// Generate slug from name if not provided
	targetSlug := getSlug(nil, doc.Name)

	// First, try to find existing system by slug
	limit := 1000
	listResp, err := client.ListSystemsWithResponse(ctx, workspaceID, &api.ListSystemsParams{Limit: &limit})
	if err != nil {
		result.Error = fmt.Errorf("failed to list systems: %w", err)
		return result, result.Error
	}

	if listResp.JSON200 == nil {
		result.Error = fmt.Errorf("failed to list systems: %s", string(listResp.Body))
		return result, result.Error
	}

	var existingIDs []string
	for _, sys := range listResp.JSON200.Items {
		if sys.Slug == targetSlug || sys.Name == doc.Name {
			existingIDs = append(existingIDs, sys.Id)
		}
	}
	if len(existingIDs) > 1 {
		result.Error = fmt.Errorf("multiple systems found with name or slug '%s'; please ensure uniqueness", doc.Name)
		return result, result.Error
	}
	var existingID string
	if len(existingIDs) == 1 {
		existingID = existingIDs[0]
	}

	if existingID != "" {
		// Update existing system
		resp, err := client.UpsertSystemByIdWithResponse(ctx, workspaceID, existingID, api.UpsertSystemByIdJSONRequestBody{
			Name:        doc.Name,
			Description: doc.Description,
		})
		if err != nil {
			result.Error = fmt.Errorf("failed to update system: %w", err)
			return result, result.Error
		}
		if resp.JSON200 == nil {
			result.Error = fmt.Errorf("failed to update system: %s", string(resp.Body))
			return result, result.Error
		}
		result.ID = existingID
		result.Action = "updated"
	} else {
		// Create new system (slug is auto-generated by the server)
		resp, err := client.CreateSystemWithResponse(ctx, workspaceID, api.CreateSystemJSONRequestBody{
			Name:        doc.Name,
			Description: doc.Description,
		})
		if err != nil {
			result.Error = fmt.Errorf("failed to create system: %w", err)
			return result, result.Error
		}
		if resp.JSON202 == nil {
			result.Error = fmt.Errorf("failed to create system: %s", string(resp.Body))
			return result, result.Error
		}
		result.ID = resp.JSON202.Id
		result.Action = "created"
	}

	return result, nil
}

// ApplyDeployment creates or updates a deployment
// Uses slug as the stable identifier for matching. If no slug is provided, one is generated from the name.
func ApplyDeployment(ctx context.Context, client *api.ClientWithResponses, workspaceID string, resolver *ResourceResolver, doc *DeploymentDocument) (*ApplyResult, error) {
	result := &ApplyResult{
		Kind: KindDeployment,
		Name: doc.Name,
	}

	// Resolve system ID
	systemID, err := resolver.ResolveSystemID(ctx, doc.System)
	if err != nil {
		result.Error = err
		return result, err
	}

	// Generate slug from name if not provided
	targetSlug := getSlug(doc.Slug, doc.Name)

	// Build resource selector
	selector, err := buildSelector(&SelectorConfig{Cel: doc.ResourceSelector})
	if err != nil {
		result.Error = err
		return result, err
	}

	// Find existing deployment by slug within the system
	limit := 1000
	listResp, err := client.ListDeploymentsWithResponse(ctx, workspaceID, &api.ListDeploymentsParams{Limit: &limit})
	if err != nil {
		result.Error = fmt.Errorf("failed to list deployments: %w", err)
		return result, result.Error
	}

	var existingID string
	if listResp.JSON200 != nil {
		for _, dep := range listResp.JSON200.Items {
			// Match by slug and ensure it's in the same system
			if dep.Deployment.Slug == targetSlug && dep.Deployment.SystemId == systemID {
				existingID = dep.Deployment.Id
				break
			}
		}
	}

	jobAgentConfig := map[string]interface{}{}
	if doc.JobAgentConfig != nil {
		jobAgentConfig = doc.JobAgentConfig
	}

	if existingID != "" {
		// Update existing deployment
		resp, err := client.UpsertDeploymentWithResponse(ctx, workspaceID, existingID, api.UpsertDeploymentJSONRequestBody{
			Name:             doc.Name,
			Slug:             targetSlug,
			SystemId:         systemID,
			Description:      doc.Description,
			ResourceSelector: selector,
			JobAgentId:       doc.JobAgentId,
			JobAgentConfig:   &jobAgentConfig,
		})
		if err != nil {
			result.Error = fmt.Errorf("failed to update deployment: %w", err)
			return result, result.Error
		}
		if resp.JSON202 == nil {
			result.Error = fmt.Errorf("failed to update deployment: %s", string(resp.Body))
			return result, result.Error
		}
		result.ID = resp.JSON202.Id
		result.Action = "updated"
	} else {
		// Create new deployment
		resp, err := client.CreateDeploymentWithResponse(ctx, workspaceID, api.CreateDeploymentJSONRequestBody{
			Name:             doc.Name,
			Slug:             targetSlug,
			SystemId:         systemID,
			Description:      doc.Description,
			ResourceSelector: selector,
			JobAgentId:       doc.JobAgentId,
			JobAgentConfig:   &jobAgentConfig,
		})
		if err != nil {
			result.Error = fmt.Errorf("failed to create deployment: %w", err)
			return result, result.Error
		}
		if resp.JSON202 == nil {
			result.Error = fmt.Errorf("failed to create deployment: %s", string(resp.Body))
			return result, result.Error
		}
		result.ID = resp.JSON202.Id
		result.Action = "created"
	}

	return result, nil
}

// ApplyEnvironment creates or updates an environment
func ApplyEnvironment(ctx context.Context, client *api.ClientWithResponses, workspaceID string, resolver *ResourceResolver, doc *EnvironmentDocument) (*ApplyResult, error) {
	result := &ApplyResult{
		Kind: KindEnvironment,
		Name: doc.Name,
	}

	// Resolve system ID
	systemID, err := resolver.ResolveSystemID(ctx, doc.System)
	if err != nil {
		result.Error = err
		return result, err
	}

	// Build resource selector
	selector, err := buildSelector(doc.ResourceSelector)
	if err != nil {
		result.Error = err
		return result, err
	}

	// Find existing environment by name within the system
	limit := 1000
	listResp, err := client.ListEnvironmentsWithResponse(ctx, workspaceID, &api.ListEnvironmentsParams{Limit: &limit})
	if err != nil {
		result.Error = fmt.Errorf("failed to list environments: %w", err)
		return result, result.Error
	}

	var existingID string
	if listResp.JSON200 != nil {
		for _, env := range listResp.JSON200.Items {
			// Match by name and ensure it's in the same system
			if env.Environment.Name == doc.Name && env.Environment.SystemId == systemID {
				existingID = env.Environment.Id
				break
			}
		}
	}

	if existingID != "" {
		// Update existing environment
		resp, err := client.UpsertEnvironmentByIdWithResponse(ctx, workspaceID, existingID, api.UpsertEnvironmentByIdJSONRequestBody{
			Name:             doc.Name,
			SystemId:         systemID,
			Description:      doc.Description,
			ResourceSelector: selector,
		})
		if err != nil {
			result.Error = fmt.Errorf("failed to update environment: %w", err)
			return result, result.Error
		}
		if resp.JSON200 == nil {
			result.Error = fmt.Errorf("failed to update environment: %s", string(resp.Body))
			return result, result.Error
		}
		result.ID = resp.JSON200.Id
		result.Action = "updated"
	} else {
		// Create new environment
		resp, err := client.CreateEnvironmentWithResponse(ctx, workspaceID, api.CreateEnvironmentJSONRequestBody{
			Name:             doc.Name,
			SystemId:         systemID,
			Description:      doc.Description,
			ResourceSelector: selector,
		})
		if err != nil {
			result.Error = fmt.Errorf("failed to create environment: %w", err)
			return result, result.Error
		}
		if resp.JSON202 == nil {
			result.Error = fmt.Errorf("failed to create environment: %s", string(resp.Body))
			return result, result.Error
		}
		result.ID = resp.JSON202.Id
		result.Action = "created"
	}

	return result, nil
}

// ApplyPolicy creates or updates a policy
func ApplyPolicy(ctx context.Context, client *api.ClientWithResponses, workspaceID string, doc *PolicyDocument) (*ApplyResult, error) {
	result := &ApplyResult{
		Kind: KindPolicy,
		Name: doc.Name,
	}

	// Find existing policy by name
	listResp, err := client.ListPoliciesWithResponse(ctx, workspaceID, nil)
	if err != nil {
		result.Error = fmt.Errorf("failed to list policies: %w", err)
		return result, result.Error
	}

	var existingID string
	if listResp.JSON200 != nil {
		for _, pol := range listResp.JSON200.Items {
			if pol.Name == doc.Name {
				existingID = pol.Id
				break
			}
		}
	}

	// Build selectors (use empty slice, not nil, so JSON marshals to [] not null)
	selectors := make([]api.PolicyTargetSelector, 0)
	for _, sel := range doc.Selectors {
		apiSel := api.PolicyTargetSelector{}
		if sel.DeploymentSelector != nil {
			s, err := buildSelector(sel.DeploymentSelector)
			if err != nil {
				result.Error = err
				return result, err
			}
			apiSel.DeploymentSelector = s
		}
		if sel.EnvironmentSelector != nil {
			s, err := buildSelector(sel.EnvironmentSelector)
			if err != nil {
				result.Error = err
				return result, err
			}
			apiSel.EnvironmentSelector = s
		}
		if sel.ResourceSelector != nil {
			s, err := buildSelector(sel.ResourceSelector)
			if err != nil {
				result.Error = err
				return result, err
			}
			apiSel.ResourceSelector = s
		}
		selectors = append(selectors, apiSel)
	}

	if existingID != "" {
		// Update existing policy
		resp, err := client.UpdatePolicyWithResponse(ctx, workspaceID, existingID, api.UpdatePolicyJSONRequestBody{
			Name:        doc.Name,
			Description: doc.Description,
			Enabled:     doc.Enabled,
			Priority:    doc.Priority,
			Metadata:    &doc.Metadata,
			Selectors:   &selectors,
		})
		if err != nil {
			result.Error = fmt.Errorf("failed to update policy: %w", err)
			return result, result.Error
		}
		if resp.JSON202 == nil {
			result.Error = fmt.Errorf("failed to update policy: %s", string(resp.Body))
			return result, result.Error
		}
		result.ID = resp.JSON202.Id
		result.Action = "updated"
	} else {
		// Create new policy
		resp, err := client.CreatePolicyWithResponse(ctx, workspaceID, api.CreatePolicyJSONRequestBody{
			Name:        doc.Name,
			Description: doc.Description,
			Enabled:     doc.Enabled,
			Priority:    doc.Priority,
			Metadata:    &doc.Metadata,
			Selectors:   &selectors,
		})
		if err != nil {
			result.Error = fmt.Errorf("failed to create policy: %w", err)
			return result, result.Error
		}
		if resp.JSON202 == nil {
			result.Error = fmt.Errorf("failed to create policy: %s", string(resp.Body))
			return result, result.Error
		}
		result.ID = resp.JSON202.Id
		result.Action = "created"
	}

	return result, nil
}

// ApplyRelationshipRule creates or updates a relationship rule
func ApplyRelationshipRule(ctx context.Context, client *api.ClientWithResponses, workspaceID string, doc *RelationshipRuleDocument) (*ApplyResult, error) {
	result := &ApplyResult{
		Kind: KindRelationshipRule,
		Name: doc.Name,
	}

	// Build selectors
	fromSelector, err := buildSelector(doc.FromSelector)
	if err != nil {
		result.Error = err
		return result, err
	}

	toSelector, err := buildSelector(doc.ToSelector)
	if err != nil {
		result.Error = err
		return result, err
	}

	// Build matcher
	var matcher api.CreateRelationshipRuleRequest_Matcher
	if doc.Matcher != nil && doc.Matcher.Cel != nil {
		if err := matcher.FromCelMatcher(api.CelMatcher{Cel: *doc.Matcher.Cel}); err != nil {
			result.Error = fmt.Errorf("failed to create CEL matcher: %w", err)
			return result, result.Error
		}
	}

	// Initialize metadata if nil
	metadata := doc.Metadata
	if metadata == nil {
		metadata = make(map[string]string)
	}

	// Create new relationship rule (API doesn't have list endpoint visible, use create)
	resp, err := client.CreateRelationshipRuleWithResponse(ctx, workspaceID, api.CreateRelationshipRuleJSONRequestBody{
		Name:             doc.Name,
		Reference:        doc.Reference,
		RelationshipType: doc.RelationshipType,
		FromType:         doc.FromType,
		ToType:           doc.ToType,
		Description:      doc.Description,
		Metadata:         metadata,
		FromSelector:     fromSelector,
		ToSelector:       toSelector,
		Matcher:          matcher,
	})
	if err != nil {
		result.Error = fmt.Errorf("failed to create relationship rule: %w", err)
		return result, result.Error
	}
	if resp.JSON201 == nil {
		result.Error = fmt.Errorf("failed to create relationship rule: %s", string(resp.Body))
		return result, result.Error
	}
	result.ID = resp.JSON201.Id
	result.Action = "created"

	return result, nil
}

// ApplyResource creates or updates a resource via a resource provider
// Resources are identified by their identifier within a provider
func ApplyResource(ctx context.Context, client *api.ClientWithResponses, workspaceID string, doc *ResourceDocument) (*ApplyResult, error) {
	result := &ApplyResult{
		Kind: KindResource,
		Name: doc.Name,
	}

	// Use default provider name if not specified
	providerName := doc.Provider
	if providerName == "" {
		providerName = "ctrlc-apply"
	}

	// First, try to find the resource provider by name
	providerResp, err := client.GetResourceProviderByNameWithResponse(ctx, workspaceID, providerName)
	if err != nil {
		result.Error = fmt.Errorf("failed to get resource provider: %w", err)
		return result, result.Error
	}

	var providerID string
	if providerResp.JSON200 != nil {
		providerID = providerResp.JSON200.Id
	} else {
		// Provider doesn't exist, create it
		createResp, err := client.UpsertResourceProviderWithResponse(ctx, workspaceID, api.UpsertResourceProviderJSONRequestBody{
			Id:   providerName,
			Name: providerName,
		})
		if err != nil {
			result.Error = fmt.Errorf("failed to create resource provider: %w", err)
			return result, result.Error
		}
		if createResp.JSON200 == nil {
			result.Error = fmt.Errorf("failed to create resource provider: %s", string(createResp.Body))
			return result, result.Error
		}
		providerID = createResp.JSON200.Id
	}

	// Initialize metadata if nil
	metadata := doc.Metadata
	if metadata == nil {
		metadata = make(map[string]string)
	}

	// Initialize config if nil
	config := doc.Config
	if config == nil {
		config = make(map[string]any)
	}

	// Create the resource via the provider using PATCH (upsert behavior)
	resources := []api.ResourceProviderResource{
		{
			Identifier: doc.Identifier,
			Name:       doc.Name,
			Kind:       doc.Kind,
			Version:    doc.Version,
			Config:     config,
			Metadata:   metadata,
		},
	}

	resp, err := client.SetResourceProvidersResourcesPatchWithResponse(ctx, workspaceID, providerID, api.SetResourceProvidersResourcesPatchJSONRequestBody{
		Resources: resources,
	})
	if err != nil {
		result.Error = fmt.Errorf("failed to upsert resource: %w", err)
		return result, result.Error
	}

	if resp.JSON202 == nil {
		result.Error = fmt.Errorf("failed to upsert resource: %s", string(resp.Body))
		return result, result.Error
	}

	result.ID = doc.Identifier
	result.Action = "upserted"

	vars := doc.Variables
	if vars == nil {
		vars = map[string]any{}
	}
	varsResp, err := client.UpdateVariablesForResourceWithResponse(
		ctx,
		workspaceID,
		doc.Identifier,
		api.UpdateVariablesForResourceJSONRequestBody(vars),
	)
	if err != nil {
		result.Error = fmt.Errorf("failed to update resource variables: %w", err)
		return result, result.Error
	}
	if varsResp == nil || varsResp.StatusCode() != 204 {
		body := ""
		if varsResp != nil {
			body = string(varsResp.Body)
		}
		result.Error = fmt.Errorf("failed to update resource variables: %s", body)
		return result, result.Error
	}

	return result, nil
}
